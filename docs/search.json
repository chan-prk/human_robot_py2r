[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "เกริ่นเกี่ยวกับการแข่งขัน และ small yellow duck’s solution และความสนใจของตัวเองที่มีต่อ solution นี้……….\nหน้าแรก เอาโค้ดเก่ามาทำให้รันได้\nหน้าที่สอง เพราะว่าถ้าดูโค้ดในส่วนของการ train model เจ้าของข้ามส่วนที่เป็น model/hyperparameter tuning. ก็เลยต้องใส่เองเพื่อความสมบูรณ์ อธิบายด้วยนะว่า เป็นไปได้ว่าระหว่างการแข่งขันเจ้าของอาจจะมีโค้ดส่วนนี้เพื่อหา algorithm หรือ parameter ที่ดีที่สุด แต่หลังจากสิ้นสุดการแข่งแล้ว เจ้าของซึ่งรู้คำตอบอยู่แล้วน่าจะ hard code ลงไปใน script ที่แชร์ให้สาธารณะ โดยที่ผู้ที่มาดาวน์โหลด script สามารถ นำไปใช้ได้โดยไม่ต้องเสียเวลารัน script เป็นเวลานานเพื่อหาคำตอบว่า algorithm/parameter ไหนดีที่สุด)\nหน้าที่สาม กับ หน้าที่สี่ จะเป็นการ เขียนโค้ดขึ้นใหม่โดยอิงจากโค้ดใน section ก่อนหน้า ส่วนหลักๆในโค้ด ตามที่เราได้เห็นกันมา ก็เป็นการสร้าง feature และ train model ซึ่งเราจะอธิบายส่วนนี้ในหน้าสาม นอกจากนี้ ถ้าสังเกตใน original code ก็จะมีโค้ดส่วนที่เป็น data visualization ที่ถูก comment ไว้ ในหน้าที่สี่เราจะแสดง plot ที่ถูกสร้างใน step นี้",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/running.html",
    "href": "pages/running.html",
    "title": "Run Original Code (Python 2.7) on Kaggle",
    "section": "",
    "text": "ก่อนที่จะเริ่มต้นทำการพอร์ตโค้ดจาก Python เป็น R สิ่งแรกที่ผมทำคือการรันโค้ดต้นฉบับดูก่อน การทำแบบนี้มีประโยชน์คือ หลังจากที่เราสามารถรันโค้ดต้นฉบับได้แล้ว เราจะได้เอาต์พุตคือไฟล์ที่ชื่อว่า submission.csv ซึ่งเราสามารถทำการ submit เข้าไปยังการแข่งขันในเว็บ Kaggle และได้รับแจ้งว่าคะแนนเป็นเท่าไหร่ ในภายหลังเราสามารถใช้คะแนนนี้เป็น baseline ในการชี้วัดว่า R implementation ของเราทำงานถูกหรือไม่ โดยการ submit เอาต์พุตที่ได้มาจากการรันโค้ด R แล้วเปรียบเทียบคะแนนที่ได้รับกับคะแนนของโค้ดต้นฉบับ\nNote.\n\nโค้ดต้นฉบับสามารถดาวน์โหลดได้จาก small yellow duck’s github \nด้วยการแก้ไขจากโค้ดต้นฉบับ ผมได้สร้างโค้ดพร้อมคะแนนจากการ submit ไว้แล้วเป็น Kaggle’s notebook สามารถดูได้ที่ Kaggle\n\nคะแนนของ submission ใน notebook จะเป็น 0.93888 (Private Score)\nคะแนนของ small yellow duck ถ้าดูจาก leaderboard จะเป็น 0.94167\n\n\nจะเห็นว่าคะแนนจาก script ที่ผมวางใน kaggle กับ คะแนนของ small yellow duck มีความเตกต่างกันอยู่ ความแตกต่างนี้อาจเกิดได้จากหลายสาเหตุเช่น เวอร์ชั่นก์ของ Python รวมถึงแพ็คเกจที่ทำการติดตั้งไม่เหมือนกันทั้งหมด (เราไม่มีทางทราบว่า small yellow duck ใช้ package เวอร์ชั่นไหนบ้างเนื่องจากไม่ได้เปิดเผย requirements.txt) สาเหตุอื่นก็อย่างเช่น random seed ของ machine learning model แตกต่างกัน เป็นต้น\nอย่างไรก็ดี คะแนน 0.93888 ของโค้ดของผม ก็จัดว่าเป็นคะแนนที่สูงถ้าเทียบกับผู้เข้าแข่งขันอื่นๆใน leaderboard โดยที่จริงๆแล้วคะแนนนี้อยู่ระหว่างคะแนนของผู้เข้าแข่งขันที่ได้อันดับ 11 และ 12 ดังนั้นจึงอาจพอสรุปได้ว่า โค้ดที่ผมนำมาวางใน kaggle นี้เป็นโค้ดที่ใช้การได้ เหมาะแก่การนำมาเป็นต้นแบบในการเขียนขึ้นใหม่ในภาษา R\n\n\n\n\nsource: https://www.kaggle.com/competitions/facebook-recruiting-iv-human-or-bot/leaderboard",
    "crumbs": [
      "Original Code (Python)",
      "1. Get It Up and Running"
    ]
  },
  {
    "objectID": "pages/running.html#guess-the-python-version",
    "href": "pages/running.html#guess-the-python-version",
    "title": "Run Original Code (Python 2.7) on Kaggle",
    "section": "Guess the Python Version",
    "text": "Guess the Python Version\nโค้ดต้นฉบับของ small yellow duck ถูกคอมมิตใน github ในเดือนมิถุนายนปี 2015 (ดูได้จาก github ) ซึ่งในช่วงนั้น Python 2 ยังเป็นที่นิยมใช้กันอยู่ จึงมีความเป็นไปได้ว่า โค้ดต้นฉบับจะใช้ Python เวอร์ชั่นก์นี้ นอกจากนี้ยังมีอีกข้อสังเกตหนึ่งคือ ในโค้ดของ small yellow duck มีการใช้คำสั่ง print โดยไม่ใส่วงเล็บล้อมอาร์กิวเมนต์ ซึ่งใน Python 3 ไม่อนุญาตให้ทำแบบนี้ ในขณะที่ใน Python 2 สามารถทำได้\ndef bid_order(X, bids):\n    bids = bids.groupby('auction').apply(enumerate)\n    \n    a = bids.sort('time', ascending=True).groupby('auction', as_index=False).first()\n    b = a.groupby('bidder_id').size().reset_index()\n    b= b.rename(columns = {0:'num_first_bid'})    \n    X = pd.merge(X, b, on='bidder_id', how='left')\n    print X.columns\n    ...\nเพื่อความเฉพาะเจาะจงยิ่งขึ้น เรามาดู chart ที่บ่งบอกถึงสถานะเวอร์ชันของ Python จะเห็นได้ว่า ณ ปี 2015 Python 2.6 จะเก่าเกินไปเพราะอยู่ในสถานะ end-of-life ผมจึงคิดว่า ณ ขณะนั้น มีความเป็นไปได้ว่า small yellow duck จะใช้ Python 2.7 มากที่สุด\n\n\n\n\nsource: https://devguide.python.org/versions/",
    "crumbs": [
      "Original Code (Python)",
      "1. Get It Up and Running"
    ]
  },
  {
    "objectID": "pages/running.html#install-python-2.7-and-dependencies",
    "href": "pages/running.html#install-python-2.7-and-dependencies",
    "title": "Run Original Code (Python 2.7) on Kaggle",
    "section": "Install Python 2.7 and Dependencies",
    "text": "Install Python 2.7 and Dependencies\nณ เวลาที่เขียนบทความนี้ เวอร์ชั่นของ Python ที่รันบน Kaggle notebook เป็น Python 3.13 ดังนั้นถ้าเราจะรัน Python 2.7 จะต้องหาวิธีรัน Python หลายเวอร์ชั่น บน notebook ซึ่งผมจะใช้ เครื่องมือที่ชื่อว่า Miniconda เพื่อทำสิ่งนี้\n\n\n\n\nDefault เวอร์ชั่นของ Python ใน Kaggle notebook, ข้อมูล ณ กรกฎาคม 2025\n\n\n\n\n\n\n\nsource: คำตอบจาก Gemini\n\n\n\n\nInstall Miniconda\nจากการเข้าไปดูในเนื้อหาของไฟล์ในโฟลเดอร์ etc พบว่า Kaggle notebook รันอยู่บนระบบปฎิบัติการ Ubuntu ซึ่งเป็น Linux\n\n\n\n\nเวอร์ชั่นของระบบปฎิบัติการที่ Kaggle notebook ตั้งอยู่\n\n\n\nซึ่งถ้าเข้าไปดูขั้นตอนการติดตั้ง Miniconda ใน official website ก็จะพบคำแนะนำให้ติดตั้งด้วยคำสั่งดังต่อไปนี้\nmkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm ~/miniconda3/miniconda.sh\nใน notebook ของผม ได้ทำการแก้ไขเล็กน้อยในบรรทัดที่สาม โดยได้แก้ argument ตัวสุดท้ายให้เป็น /usr/local\nbash ~/miniconda3/miniconda.sh -b -u -p /usr/local\nที่ทำอย่างนี้เพื่อให้ executable conda ถูกติดตั้งลงไปใน /usr/local/bin ซึ่งอยู่ใน environment variable PATH อยู่แล้ว\n\n\n\n\nโฟลเดอร์ที่ miniconda ทำการติดตั้ง และ PATH\n\n\n\n\n\nCreat Environment and Activate it\nเราสามารถใช้ คำสั่ง conda ในการสร้าง virtual environment โดยที่ระบุเวอร์ชั่นของ Python ที่จะให้ทำการติดตั้งด้วยได้\n!conda create -y -q --name py27 python=2.7\nหลังจากสร้าง virtual environment แล้ว เราสามารถ activate มันเพื่อใช้งาน  ในรูปด้านล่างแสดงถึง\n\nก่อนที่เราจะ activate ถ้าใช้คำสั่ง python จะเป็นการเรียก python default version ของ Kaggle notebook\nภายในบรรทัดเดียวกับที่เรา activate virtual environment (ที่มีชื่อว่า py27) การใช้คำสั่ง python จะไปเรียก python เวอร์ชั่นที่เราติดตั้งไว้ใน environment\n\n\n\n\n\nบรรทัดแรก รัน Python เฉยๆ ในขณะที่บรรทัดที่สอง รัน Python พร้อมกับ activate virtual environment\n\n\n\n\n\nInstall Dependencies\nVirtual environment ที่เพิ่งถูกสร้างขึ้นมา ถึงแม้จะมีเวอร์ชันของ Python ที่เข้ากันได้กับโค้ดของ small yellow duck แล้ว แต่ตัวโค้ดก็ยังไม่สามารถรันได้ เพราะใน environment ยังไม่ได้ทำการลง Python packages ที่ในโค้ดใช้\nเราสามารถดูว่า packages ที่ต้องติดตั้งมีอะไรบ้างได้จากที่บรรทัดที่เป็นการ import\nimport pandas as pd\nimport numpy as np\n#from matplotlib import pyplot as plt\n\nimport sklearn.preprocessing as preprocessing\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import AdaBoostClassifier\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.ensemble import ExtraTreesClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.linear_model import LogisticRegression, BayesianRidge\nfrom sklearn.cluster import MiniBatchKMeans\nfrom sklearn.metrics import roc_auc_score\nจะเห็นได้ว่า package ที่ในโค้ดใช้ก็จะมี pandas, numpy, matplotlib และ scikit-learn เท่านั้น\nทีนี้หากผู้อ่านดูโค้ดด้านบนอาจจะสังเกตว่าบรรทัด matplotlib ได้ถูกคอมเมนต์ไว้ ซึ่งผมขอสารภาพว่าผมเป็นคนคอมเมนต์ออกเอง เหตุผลมาจากว่า การที่มีบรรทัดนี้อยู่จะบังคับให้ ผมต้องติดตั้ง package ที่ชื่อ matplotlib-inline ซึ่งตัว installer ไม่สามารถหาเวอร์ชั่นที่เหมาะสมกับ Python 2.7 ได้ ดังที่แสดงไว้ใน error ด้านล่าง\nCould not solve for environment specs\nThe following packages are incompatible\n├─ matplotlib-inline =* * is installable with the potential options\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.10,&lt;3.11.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.11,&lt;3.12.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.12,&lt;3.13.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.13,&lt;3.14.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.7,&lt;3.8.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.8,&lt;3.9.0a0 *, which can be installed;\n│  ├─ matplotlib-inline 0.1.6 would require\n│  │  └─ python &gt;=3.9,&lt;3.10.0a0 *, which can be installed;\n│  └─ matplotlib-inline 0.1.2 would require\n│     └─ python &gt;=3.6 *, which can be installed;\n└─ pin on python 2.7.* =* * is not installable because it requires\n   └─ python =2.7 *, which conflicts with any installable versions previously reported.\n\nPins seem to be involved in the conflict. Currently pinned specs:\n - python=2.7\nอย่างไรก็ดี ถ้าลองอ่านโค้ดต้นฉบับดูจะพบว่า บรรทัดที่เกี่ยวกับการ plot โดยใช้ matplotlib นั้นถูกคอมเมนต์ไว้โดย small yellow duck อยู่แล้ว ทำให้จริงๆแล้วถึงจะไม่ import matplotlib โค้ดก็สามารถทำงานได้ตามปกติ\n\n\nIssues with Pandas\nขออนุญาตย้อนกลับมาเรื่องการ ติดตั้ง package ใน virtual environment นะครับ  เช่นเดียวกับที่เรารัน “python –version” พร้อมกับการ activate environment ใน section ด้านบน เราสามารถรัน “python -m pip install” เพื่อทำการติดตั้ง package ลงในไลบรารีของ environment ที่เรา activate ได้\nคำสั่งด้านล่างทำการติดตั้ง pandas, numpy และ scikit-learn ลงใน virtual environment py27\n!source activate py27 && python -m pip install pandas numpy scikit-learn\nอย่างไรก็ดี คำสั่งนี้มีปัญหาก็คือ เนื่องจากเราไม่ระบุเวอร์ชันที่เจาะจงของ package ตัว pip จะลง pandas(และ numpy, scikit-learn) เป็นเวอร์ชันที่ใหม่ที่สุดที่เข้ากันได้กับ Python 2.7 ผลลัพธ์ของการรันโค้ดต้นฉบับ หลังจากติดตั้ง package ด้วยคำสั่งนี้คือ error\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1015, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 69, in load\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/core/generic.py\", line 5067, in __getattr__\n    return object.__getattribute__(self, name)\nAttributeError: 'DataFrame' object has no attribute 'sort'\nError นี้เกิดมาจากการที่ โค้ดต้นฉบับใช้ฟังก์ชัน sort ของ object DataFrame\ndef load():\n    ...\n    bids = bids.sort(['auction', 'time'])\n    ...\n    b = bot_or_human[['bidder_id', 'address']].groupby('address').size().reset_index().sort(0, ascending=False)\n        ...\nซึ่งฟังก์ชั่นนี้ใช้ได้แต่เฉพาะใน pandas ในเวอร์ชันที่ค่อนข้างเก่า แต่ในคำสั่งติดตั้งของเราเลือกลง pandasเวอร์ชั่นใหม่ที่สุดที่เป็นไปได้(สำหรับ Python 2.7)\nข้อมูลจาก Stackoverflow ระบุว่าฟังก์ชั่นนี้ถูก deprecated ใน Pandas เวอร์ชัน 0.17.0 และถูกเอาออกใน เวอร์ชัน 0.20.0\n\n\n\n\nsource: https://stackoverflow.com/a/44123892/718529\n\n\n\nจากข้อมูลตรงนี้ สิ่งที่สมเหตุสมผลที่สุดก็คือการ ติดตั้งโดยระบุเวอร์ชันของ Pandas เป็นเวอร์ชันก่อน 0.17.0 อย่างไรก็ดี ผมได้ลองติดตั้งทั้ง Pandas 0.14.X, 0.15.X และ 0.16.X แล้วพบว่าเมื่อรันโค้ดต้นฉบับภายหลังการติดตั้ง จะเกิด ImportError คล้ายๆกันหมดในทุกเวอร์ชัน ต่อไปนี้เป็นตัวอย่าง error ที่พบ (ขออนุญาตนำมาแสดงเพียงสองเวอร์ชันเท่านั้น)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 14, in &lt;module&gt;\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/__init__.py\", line 6, in &lt;module&gt;\n    from . import hashtable, tslib, lib\nImportError: /usr/local/envs/py27/lib/python2.7/site-packages/pandas/lib.so: undefined symbol: is_float_object\nผลลัพธ์ของการรันโค้ด Python เมื่อทำการลง pandas 0.14.1\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 14, in &lt;module&gt;\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/__init__.py\", line 7, in &lt;module&gt;\n    from . import hashtable, tslib, lib\n  File \"pandas/tslib.pyx\", line 2839, in init pandas.tslib (pandas/tslib.c:80041)\n  File \"pandas/algos.pyx\", line 64, in init pandas.algos (pandas/algos.c:180213)\nImportError: /usr/local/envs/py27/lib/python2.7/site-packages/pandas/lib.so: undefined symbol: is_float_object\nผลลัพธ์ของการรันโค้ด Python เมื่อทำการลง pandas 0.15.0\nError คล้ายๆกันนี้เกิดขึ้นไปจนถึง Pandas เวอร์ชัน 0.17.X จนเมื่่อผมลองติดตั้ง Pandas 0.18.0 ปัญหาก็หายไป สรุปความได้ว่าคำสั่งติดตั้ง packages ที่ผมตัดสินใจใช้ในโค้ดที่ทำการแก้ไขก็จะเป็น\n!source activate py27 && python -m pip install pandas==0.18.0 numpy scikit-learn\nซึ่ง ณ เวอร์ชั่นนี้ ฟังก์ชั่น DataFrame.sort ยังถูกแค่เพียง deprecated เท่านั้นแต่ยังไม่ถูก removed ดังนั้นข้อเสียก็จะเป็นเพียงว่าเวลารันโค้ดจะมีคำเตือนแบบนี้ปรากฎ\n&lt;stdin&gt;:70: FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....)",
    "crumbs": [
      "Original Code (Python)",
      "1. Get It Up and Running"
    ]
  },
  {
    "objectID": "pages/running.html#edit-and-run-the-code",
    "href": "pages/running.html#edit-and-run-the-code",
    "title": "Run Original Code (Python 2.7) on Kaggle",
    "section": "Edit and Run the Code",
    "text": "Edit and Run the Code\nมีสองจุดที่ต้องทำการแก้ไข ก่อนที่จะทำให้โค้ดสามารถรันได้\nประการแรกไม่ซับซ้อนอะไร เนื่องจากว่าตัวโค้ดต้นฉบับจะทำแค่ประกาศและเขียนโค้ดของฟังก์ชั่น ถ้าเราจะรันก็จะต้องเพิ่มบรรทัดที่สั่งรันฟังชันก์เหล่านั้นเท่านั้นเอง ซึ่ง small yellow duck ได้ใส่คำอธิบายวิธีรันโค้ดไว้ในคอมเมนต์ด้านบนสุดของโค้ดดังในรูป\n\n\n\n\nคอมเมนต์โดย small yellow duck\n\n\n\nซึ่งผมก็แค่นำโค้ดจากคอมเมนต์มาใส่ไว้ที่ด้านล่างสุดของโค้ดก่อนที่จะคลิกรันใน Kaggle notebook\n\n\n\n\nเพิ่มการสั่งรันโค้ดไว้ที่ด้านล่างสุดของโค้ด\n\n\n\n\nFix KeyError\nหลังจากแก้ไขจุดแรกไปแล้วและสั่งรัน ผลลัพธ์คือ KeyError ซึ่งนี่แหละคือจุดที่สองซึ่งต้องทำการแก้ไข(เพื่อให้ error นี้หายไป)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1020, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 858, in build_X\n  File \"&lt;stdin&gt;\", line 494, in user_countries_per_auction\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/core/frame.py\", line 1986, in __getitem__\n    return self._getitem_array(key)\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/core/frame.py\", line 2030, in _getitem_array\n    indexer = self.ix._convert_to_indexer(key, axis=1)\n  File \"/usr/local/envs/py27/lib/python2.7/site-packages/pandas/core/indexing.py\", line 1210, in _convert_to_indexer\n    raise KeyError('%s not in index' % objarr[mask])\nKeyError: \"['most_common_country'] not in index\"\nเพื่อทำความเข้าใจปัญหา ผมได้เข้าไปดูบรรทัดรอบๆจุดที่เกิด error ตามที่แจ้งมาใน error message ด้านบน (รอบๆบรรทัด 494 ในฟังก์ชั่น user_countries_per_auction)\n\n\n\n\nรอบๆบรรทัดที่เกิด KeyError\n\n\n\nหลังจากนั้นผมได้แยกโค้ดเฉพาะส่วนนี้ออกมา และทำการ print เพื่อสังเกต data frame ที่ถูกสร้างขึ้นระหว่างที่บรรทัดเหล่านี้รัน\nwith open('bidsX.pkl', 'rb') as f: # 'wb' for write binary mode\n    bids, X = pickle.load(f)\n    \na = bids.groupby(['bidder_id']).country.value_counts().reset_index()\nprint(a.head(20)) # (a)\nb = a.groupby(['bidder_id']).agg(lambda x: x.iloc[0]).reset_index()\nprint(b.head(20)) # (b1)\nb= b.rename(columns = {'level_1':'most_common_country'})\nprint(b.head(20)) # (b2)\nX = pd.merge(X, b[['bidder_id','most_common_country']], on='bidder_id', how='left')\n\n\n\n\n\n\n \n\n\n\n\n\nOutput A: a.head(20)\n\n\n\n\n \n\n\n\n\n\n\n\nOutput B1: b.head(20)\n\n\n\n\n\n\n\nOutput B2: b.head(20)\n\n\n\n\n\nสิ่งแรกที่สังเกตได้คือเอาต์พุทจากบรรทัด b1 และ b2 เหมือนกัน ซึ่งตรงนี้ทำให้คิดว่า บรรทัดที่อยู่เหนือ b2 ล้มเหลวในการเปลี่ยนชื่อคอลัมน์ให้เป็น most_common_country (ถ้าหากมันไม่ล้มเหลว ชื่อคอลัมน์ most_common_countryควรจะปรากฎใน header ของ data frame ในเอาต์พุท B2)\nจุดน่าสนใจที่สองคือ ถ้าเราดูความสัมพันธ์ระหว่างเอาต์พุท A และ B1 จะสังเกตเห็นว่า แต่ละแถวใน B1 มาจาก การเลือกแถวใน A ที่มีค่าในคอลัมน์ที่สามมากที่สุดสำหรับแต่ละ bidder_id หากให้ตีความแบบคร่าวๆ วัตถุประสงค์ของบรรทัดที่อยู่เหนือ b1 ก็คือการเลือกแถวออกมาจาก data frame a โดยใช้ “ความถี่” เป็นเกณฑ์\nข้อสังเกตที่สองบ่งบอกเป็นนัยๆว่า บางทีเราอาจจะต้องการเปลี่ยนชื่อของคอลัมน์ที่สองในเอาต์พุท B1 จาก country เฉยๆให้เป็น most_common_country เพราะความหมายของคำว่า most common ม้นบ่งบอกถึงการที่ประเทศนั้นมีความถี่มากที่สุด ความต้องการที่จะเปลี่ยนชื่อนี้นำไปสู่การใช้คำสั่ง rename จากชื่อ level_1 ซึ่งไม่ประสบความสำเร็จตามข้อสังเกตแรก ซึ่งเป็นไปได้ว่า ในโค้ดต้นฉบับจริงๆที่ small yellow duck ใช้ตอนปี 2015 data frame b ณ บรรทัดนี้(บรรทัดที่มี rename) มีชื่อคอลัมน์ว่า level_1 แทนที่จะเป็น country\nหรือก็คือปัญหาเกิดจากว่าภายใต้ environment/package version ที่แตกต่างกันระหว่างโค้ดของผม กับ small yellow duck ทำให้ b ที่ถูกสร้างมาจากบรรทัดเหนือ b1 มีความแตกต่างกัน คือคอลัมน์ที่สองของผมชื่อว่า country ส่วนของ small yellow duck ชื่อคอลัมน์จะเป็น level_1\nไม่ว่าชื่อคอลัมน์ ณ เอาต์พุท B1 จะเป็นอะไรก็ตามแต่ ความพยายามที่ small yellow duck จะเปลี่ยนมันให้เป็น most_common_country ก็เป็นเครื่องยืนยันว่าการคำนวณที่เกิดขึ้นนั้นถูก(การที่ในโค้ดของเราเลือกแถวที่ความถี่สูงสุดมาไว้ในเอาต์พุท B1) ที่เหลือก็แค่ไม่ต้องไปสนใจชื่อคอลัมน์ level_1 แค่ทำการเปลี่ยนชื่อจาก country ให้เป็น most_common_country\nการแก้ไขด้านล่างทำให้โค้ดรันได้สำเร็จจนกระทั่งผลิตไฟล์เอาต์พุท submission.csv\n\n\n\n\nส่วนที่แก้ไขเพื่อกำจัด KeyError",
    "crumbs": [
      "Original Code (Python)",
      "1. Get It Up and Running"
    ]
  }
]